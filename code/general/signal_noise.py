###########################################################################
# This module is for quickly filtering signal+noise maps 				  #
# some parts are adapted from LensTools modules by Andrea Petri:          #	  					  
# https://github.com/apetri/LensTools/tree/master/lenstools/              #
###########################################################################

import numpy as np
import constants as const
import os 
from scipy import interpolate
import sys
from extra_funcs import *
import matplotlib.pyplot as plt
#figure out directory to correctly find the noise files
this_dir=os.path.dirname(os.path.abspath(__file__))
NOISE_DIR=this_dir.replace("code/general","data")
FILTER_DIR=this_dir.replace("code/general","data")

class SignalNoise:

	def __init__(self, n_pixels_side, side_angle_arcmin):
		#assumes the shape is a square
		self.n_pixels_side=n_pixels_side
		self.side_angle_arcmin = side_angle_arcmin

		#convert to radians
		self.side_angle_rad = self.side_angle_arcmin*const.arcmin_to_rad
		self.ell_map=get_ell_map(self.n_pixels_side, self.side_angle_rad)
		
	def signal_noise_filter_fourier(self, signal_map, noise_map_fourier, base_filter, 
								signal_FWHM_arcmin, tot_FWHM_arcmin=0, extra_filter='', return_filter=False, **kwargs):
		"""
		This function is used to combine signal map with noise and
		filter, all in fourier space.
		
		INPUT:
		
		signal_map: numpy array of the signal map (e.g. apodized tSZ map)
		noise_map_fourier: noise map in fourier space (e.g. generated by noise module)
		base_filter: file name that contains some ell filter that will be applied to both signal & noise 
		(.npy file in /data directory with dictionary keys "ell" and "ell_filter")
		signal_FWHM_arcmin: smoothing FWHM for the signal map.
		tot_FWHM_arcmin: smoothing FWHM for the total map (default=0 i.e. no smoothing of the combined map)
		extra_filter: file name that contains some ell filter that will be applied to the composite map (e.g. wiener filter)
		**kwargs: extra arguments for interpolation of filters
		
		OUTPUT:
		real_map: map of signal+noise in real space
		
		"""
		
		#fft the signal map
		if np.count_nonzero(signal_map)==0.0:
			print("signal map is zero")
			signal_map_fourier=np.zeros((self.n_pixels_side, self.n_pixels_side))
		else:
			signal_map_fourier=np.fft.fft2(signal_map)
		
		#get a Gaussian filter
		sigma_rad=signal_FWHM_arcmin*const.FWHM_to_sigma*const.arcmin_to_rad
		self.gauss_filter=np.exp(-0.5*self.ell_map**2.0*sigma_rad**2.0)

		#make a filter function from file
		if len(base_filter)>0:
			print("filtering low or high ell")
			ell_filter_file = np.load(os.path.join(FILTER_DIR,base_filter),allow_pickle=True).item()
			ell_filter_interp = interpolate.interp1d(ell_filter_file['ell'],ell_filter_file['ell_filter'],**kwargs)
			self.ell_filter=ell_filter_interp(self.ell_map)
		else:
			print("not filtering low or high ell")
			self.ell_filter=np.ones((self.n_pixels_side, self.n_pixels_side))

		#smooth tSZ+noise
		if tot_FWHM_arcmin>0:
			print("smoothing signal and noise with a gaussian")
			tot_sigma_rad=tot_FWHM_arcmin*const.FWHM_to_sigma*const.arcmin_to_rad
			self.tot_gauss_filter=np.exp(-0.5*self.ell_map**2.0*tot_sigma_rad**2.0)
			filtered_fourier=(signal_map_fourier*self.gauss_filter+noise_map_fourier)*self.ell_filter*self.tot_gauss_filter
		
		#wiener filter tSZ+noise
		elif len(extra_filter)>0:
			print(f"applying {extra_filter} on signal and noise")
			extra_ell_filter_file = np.load(os.path.join(FILTER_DIR,extra_filter),allow_pickle=True).item()
			extra_ell_filter_interp = interpolate.interp1d(extra_ell_filter_file['ell'],extra_ell_filter_file['ell_filter'],**kwargs)
			self.extra_ell_filter=extra_ell_filter_interp(self.ell_map)
			filtered_fourier=(signal_map_fourier*self.gauss_filter+noise_map_fourier)*self.ell_filter*self.extra_ell_filter
		
		elif np.count_nonzero(noise_map_fourier)==0.0:
			print("noise map is zero")
			filtered_fourier=(signal_map_fourier*self.gauss_filter*self.ell_filter)
		#just smooth tSZ and low/high pass both tSZ and noise
		else:
			#filter signal with gaussian & taper low/high ell
			#filter noise only with low/high ell filter
			print(f"smoothing signal and applying {base_filter} on both noise and signal")
			filtered_fourier=(signal_map_fourier*self.gauss_filter+noise_map_fourier)*self.ell_filter

		real_map=np.fft.ifft2(filtered_fourier)
		
		return real_map.real


